<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JZOJ4787. 数格子]]></title>
    <url>%2F2019%2F06%2F01%2FJZOJ4787-%E6%95%B0%E6%A0%BC%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Description你有多少种方法用$2 \times 1$的多米诺骨牌填满$4 \times N$的矩形。答案会很大，所以你只需输出答案模$M$的值。 Input读入包括多组测试数据，以两个0结尾，每个测试点测试组数不超过10组。每组数据包含两个整数，$N$，$M$。 Output每行输出答案模$M$的值。 Sample Input 1 100003 100005 100000 0 Sample Output 11195 Data Constraint对于30%的数据，$1 \leq N \leq 8$。对于80%的数据，$1 \leq N \leq 10 ^ 5$。对于100%的数据，$1 \leq N \leq 10 ^ 9，1 \leq M \leq 10 ^ 5$。 80%解法$4 \times N$，一看就是状压DP，设$f[i][j]$第i列状态为j的方案数，J的每一位上0表示对下一位无影响，1表示有影响，可知$ans = f[n][0]$。可发现$f[i - 1][j]$和$f[i][k]$满足以下条件才可转移： j &amp; k = 0（j 和 k 不能有某一位同时为1）； j 和 k 都为0的位数必须为偶数并且连续。 可发现无论 i 为何值，j 状态是否能转移到 k 状态都是确定的，所以可以dfs做出转移矩阵，然后暴力转移，可拿到80分部分分。 100%解法做出转移矩阵后可发现我们推出来的DP转移式可用矩阵乘法计算，则可以用矩阵快速幂加速。注意几个可能出错的细节：矩阵乘法只满足乘法结合律，不满足乘法交换律，所以快速幂时注意相乘的顺序。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 16using namespace std;int n, m, g[4];struct arr&#123; long long a[N][N];&#125;ans, f, p;void dfs(int l, int k)&#123; if (k &gt;= N) return; int flag = 0; for (int i = 0; i &lt; 4; i++) &#123; if ((1 &lt;&lt; i &amp; k) &amp;&amp; (1 &lt;&lt; i &amp; l)) &#123; f.a[k][l] = 0; dfs(l, k + 1); return; &#125; if (!(1 &lt;&lt; i &amp; k) &amp;&amp; !(1 &lt;&lt; i &amp; l)) flag++; else if (flag &amp; 1) &#123; f.a[k][l] = 0; dfs(l, k + 1); return; &#125; else flag = 0; &#125; if (!(flag &amp; 1)) f.a[k][l] = 1; dfs(l, k + 1); return;&#125;arr ti(arr x, arr y)&#123; arr z; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) &#123; z.a[i][j] = 0; for (int k = 0; k &lt; N; k++) z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j]) % m; &#125; return z;&#125;arr ksm(arr a, int b)&#123; if (b == 1) return a; arr c = ksm(a, b &gt;&gt; 1); if (b &amp; 1) return ti(ti(c, c), a); else return ti(c, c);&#125;int main()&#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; 4; j++) g[j] = 1 &lt;&lt; j &amp; i; dfs(i, 0); ans.a[i / 4][i % 4] = 0; &#125; ans.a[0][0] = 1; while (1) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if (n == 0 &amp;&amp; m == 0) return 0; p = ti(ans, ksm(f, n)); printf(&quot;%lld\n&quot;, p.a[0][0]); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>JZOJ</tag>
        <tag>矩阵乘法</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ4788. 序列]]></title>
    <url>%2F2019%2F06%2F01%2FJZOJ4788-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Description有一个包含 n 个整数的序列$A: A_1, A_2, \ldots, A_n$，还有一个包含 n 个整数的序列$B: B_1, B_2, \ldots, B_n$在一次操作中，可以选择两个下标 i 和 j ($1 \leq i \leq j \leq n$)，然后把所有$A_i$到$A_n$之间的元素（包含），增加1之后模4。现在求将$A$数组转换成$B$，至少要执行多少次操作。 Input输入数据的第一行包含一个整数T表示数据组数。对于每组数据，第一行有一个整数，分别表示 n 。接下来两行，第一行包含 n 个数字$A_1, A_2, \ldots, A_n$，第二行包含 n 个数字$B_1, B_2, \ldots, B_n$ Output对于每组数据，输出一行表示对应的答案。 Sample Input 152 1 3 0 32 2 0 1 0 Sample Output 1 Data Constraint$1 \leq T \leq 10$$0 \leq A_i，B_i \leq 3$对于10%的数据满足，$n \leq 30$对于30%的数据满足，$n \leq 100$对于50%的数据满足，$n \leq 1000$对于60%的数据满足，$n \leq 10000$对于100%的数据满足，$n \leq 100000$ 100%解法转自扩展の灰，略作修改。我们可以先考虑不存在Mod 4 的情况，假设$d_i=max(0，b_i-a_i)$那么显然，对于一个位置 i ，我们需要将其操作$max(0，di)$次考虑从1开始，我们设$f[i]$表示将1到 i 的 d 清零所需要的最小次数。显然，$f[1]=d[1]$，$f[i]=f[i-1]+max(0，d[i]-d[i-1])$，这是一个差分的经典应用。现在我们来考虑Mod 4的情况，由于有Mod 4 的影响，我们可以将一系列的$d[i]$变为$d[i]+4k$。这样在一种情况下会减小答案。若有$i&lt;j$使得$d[i]-d[i-1]+4&lt;d[j]-d[j-1]$，那么，我们就可以将整个$[i,j-1]$的d都加上4这样答案就可以减少$(d[i]-d[i-1]+4-d[j]+d[j-1])$实际上，我们只需要维护$d[i]-d[i-1]$ = -2和-3的个数即可。（-1+4=3，0+4=4显然都不可能）每次都贪心地去取就可以。记得如果贪心到$d[i]-d[i-1]=-3$而且$d[j]-d[j-1]=2$时要把$d[i]-d[i-1] = -2$的个数加一，因为后面如果有k满足$d[k]-d[k-1]$=2或3的话把 j 用 k 替换掉是可以更优的。 Code123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int t, n, a[100010], num[4], ans = 0, b;int main()&#123; scanf(&quot;%d&quot;, &amp;t); while (t) &#123; ans = 0; memset(num, 0, sizeof num); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b), a[i] = (b - a[i] + 4) % 4; for (int i = n; i &gt;= 1; i--) a[i] -= a[i - 1]; for (int i = 1; i &lt;= n; i++) &#123; ans += max(a[i], 0); if (a[i] &lt; 0) num[a[i] + 4]++; if (num[1] &amp;&amp; a[i] &gt; 1) num[1]--, num[a[i]]++, ans -= a[i] - 1; else if (num[2] &amp;&amp; a[i] &gt; 2) num[2]--, ans -= a[i] - 2; &#125; printf(&quot;%d\n&quot;, ans); t--; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>JZOJ</tag>
        <tag>差分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my garden.]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[球盒问题]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%90%83%E7%9B%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[P.S. 转载至百度文库 一、球相同，盒子相同，且盒子不能空 例1．8个相同的球放入3个相同的盒子中，每个盒子中至少有一个，有多少种不同的放法？ 球入盒问题，可以看成分两步完成，首先是将8个球分成三堆，每堆至少一个. 由于这里球和盒子都相同，每三堆放入3个盒子中只有一种情况，所以只要将8个球分成三堆. 即1-1-6、1-2-5、1-3-4、2-2-4、2-3-3五种，故将8个相同的球放入3个相同的盒子中，每个盒子至少有一个， 有五种不同的放法.结论：ｎ个相同的球放入ｍ个相同的盒子（n≥m），不能有空盒时的放法种数等于ｎ分解为ｍ个数的和的种数. 二、球相同，盒子相同，且盒子可以空 例2．8个相同的球放入3个相同的盒子中，有多少种不同的放法？ 与上题不同的是分成的三堆中，上题中的每一堆至少有一个球，而这个题中的三堆可以有球数为零的堆，即除了分成上面的五堆外，还可分为1-7、2-6、3-5、4-4和只一堆共五种情况，故8个相同的球放入3个相同的盒子中.，有十种不同的放法.结论：ｎ个相同的球放入ｍ个相同的盒子(n $\geq$ m），可以有空盒时的放法种数等于将ｎ分解为ｍ个、(ｍ－1)个、(ｍ－2)个、$\cdots$、2个、1个数的和的所有种数之和. 三、球相同，盒子不同，且盒子不能空 例3．8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个，有多少种不同的放法？（隔板法） 这是个相同的球放入不同的盒子中，与前面不同的是，这里盒子不同，所以不能再用前面的解法. 将8个球排成一排，形成7个空隙，在7个空隙中任取两个插入两块隔板，有=种，这样将8个球分成三堆，第一堆放到1号盒子内，第二堆放到2号盒子内，第三堆放到3号盒子内. 故将8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个，有21种不同的放法.结论：ｎ个相同的球放入ｍ个不同的盒子中（n $\geq$ m），不能有空盒的放法数. 四、球相同，盒子不同，且盒子可以空 例4．8个相同的球放入标号为1、2、3的三个盒子中，有多少种不同的放法？ 与上一题不同的是，这里可以有盒子没放一个.还是利用隔板原理将8个球分为三堆，只不过有的堆的球数为零，即在8个球之间插入两块隔板。首先将8个球排成一排，就有9个空，任取一个空插入一块隔板，有$C^{1}_{9}$种；然后再将第二块隔板插入前面8个球和第一块隔板形成的10个空中，有$C^{1}_{10}$种，但这两种放法中有重复的，要除以2；最后将第一块隔板左边的球放入1号盒子中，两块隔板之间的球放入2号盒子中，第二块隔板右边的球放入3号盒子中，故一共有$\frac{1}{2}C^{1}_{9}C^{1}_{10} = C^{2}_{10} = \frac{10 \times9}{2} = 45$种.或者，将8个球分成三堆（包括没有0数堆和有0数堆），也就是在8个球的9个空隙中取两个插入隔板或取一个插入两块隔板，即$C^{1}_{9} + C^{2}_{9} = 9 + 36 = 45$种.例3也可利用上面的分法来解，8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个. 先放一个到每个盒子中，只有一种放法. 然后将剩下的5个球排成一排，插入两块隔板，有$\frac{1}{2}C^{1}_{6}C^{1}_{7} = C^{2}_{7} = \frac{7 \times6}{2} = 21$种.结论：ｎ个相同的球放入ｍ个不同的盒子中（n $\geq$ m），可以有空盒的放法数. 五、球不同，盒子相同，且盒子不能空 例5．8个不同的球放入三个相同的盒子中，每个盒子中至少有一个，有多少种不同的放法？ 由于盒子相同，所以只要对8个不同的球分成三堆就行了，因为放入盒子只有一种情况. 而8个球分成三堆，各堆球数依次为1-1-6、1-2-5、1-3-4、2-2-4、2-3-3五种. 对情况1-1-6有$\frac{C^{1}_{8}C^{1}_{7}C^{6}_{6}}{2} $种分法，对情况1-2-5有种$C^{1}_{8}C^{2}_{7}C^{5}_{5}$分法，对情况1-3-4有$C^{1}_{8}C^{3}_{7}C^{4}_{4}$种分法，对情况2-2-4有$\frac{C^{2}_{8}C^{2}_{6}C^{4}_{4}}{2}$种分法，对情况2-3-3有$\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}$（注意，分组有几组个数相同即几组均分就要除以几的阶乘）.故一共有$\frac{C^{1}_{8}C^{1}_{7}C^{6}_{6}}{2}+C^{1}_{8}C^{2}_{7}C^{5}_{5}+C^{1}_{8}C^{3}_{7}C^{4}_{4}+\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}+\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}=966$种.结论：ｎ个不同的球放入ｍ个相同的盒子中（n $\geq$ m），不能有空盒的放法种数等于ｎ个不同的球分成ｍ堆的种数. 六、球不同，盒子相同，且盒子可以空 例6．8个不同的球放入三个相同的盒子中，问有多少种不同的放法？ 只比上一题多了两种情况，一是有一堆为0的，即分成两堆，1-7、2-6、3-5、4-4四种情况，有；二是有两堆为0的，即只分成一堆，一种情况. 所以一共有966+127+1=1094种.结论 ｎ个不同的球放入ｍ个相同的盒子中（n $\geq$ m），可以有空盒的放法种数等于将ｎ个不同的球分成ｍ堆、(ｍ－1)堆、(ｍ－2)堆、$\cdots$、2堆、1堆的所有种数之和. 七、球不同，盒子不同，且盒子不能空 例7．8个不同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个. 问有多少种不同的放法？ 这个问题就等价于“8本不同的书分给3个同学，每人至少有一本，有多少种分法？”就是在例5先分堆的基础上，再加一步，分到三个不同的盒子中. 即966=5796种.结论 ｎ个不同的球放入ｍ个不同的盒子中，不能有空盒的放法种数等于ｎ个不同的球分成ｍ堆的种数乘以ｍ！. 八、球不同，盒子不同，且盒子可以空 例8．8个不同的球放入标号为1、2、3的三个盒子中，问有多少种不同的放法？ 包括分三堆的5796种，还有分两堆的127，还有只分一堆的3种情况，所以一共有5796+762+3=6561种.结论 ｎ个不同的球放入ｍ个不同的盒子中（n $\geq$ m），可以有空盒的放法种数等于$m ^ n$种.]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
        <tag>JZOJ</tag>
      </tags>
  </entry>
</search>
