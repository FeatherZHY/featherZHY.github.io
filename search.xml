<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Manachar]]></title>
    <url>%2F2020%2F01%2F01%2FManachar%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2020%2F01%2F01%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[其实就是在一颗Trie树上把多个字符串用类似于next数组的fail指针连成一个大的KMP。让被匹配的串不退回。更好地理解fail指针和如何实现移步030，博主写得实在是太可爱了=v=。 JZOJ1566 单词查找Description给一个主串S以及M个字符串。问这M个字符串在主串中出现多少次。 Input第一行一个整数N，表示S的长度。 给一个主串S以及M个字符串。问这M个字符串在主串中出现多少次。 下面M行，每行一个字符串，定义如题。 下面一行N个字母，即主串S。 Output一个正整数，表示出现的次数。 Sample Input10 3 a aba abc abcabababa Sample Output19 Hint【数据范围】 对于40％的数据，1&lt;=n&lt;=10000，1&lt;=m&lt;=100 对于100％的数据，1&lt;=n&lt;=2000000，1&lt;=m&lt;=3000，1&lt;=l&lt;=10 保证所有字母都是英文小写字母。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int len, leng, n, tot = 0, ans = 0;int w[30001], son[30001][26], fail[30001];char s[2000001];void Trie_build()&#123; int now = 0; for (int i = 0; i &lt; len; i++) &#123; int p = s[i] - 'a'; if (!son[now][p]) son[now][p] = ++tot; now = son[now][p]; &#125; w[now]++;&#125;void AC_build()&#123; int q[30001], h = 0, t = 1; q[t] = 0; while (h != t) &#123; h++; int head = q[h]; for (int i = 0; i &lt; 26; i++) &#123; if (son[head][i]) &#123; q[++t] = son[head][i]; if (!head) &#123; fail[son[head][i]] = 0; continue; &#125; int k = fail[head]; while (k &amp;&amp; !son[k][i]) k = fail[k]; fail[son[head][i]] = son[k][i]; w[son[head][i]] += w[son[k][i]]; &#125; &#125; &#125;&#125;void AC_work()&#123; int head = 0; for (int i = 0; i &lt; leng; i++) &#123; int p = s[i] - 'a'; if (son[head][p]) head = son[head][p]; else &#123; int k = fail[head]; while (k &amp;&amp; !son[k][p]) k = fail[k]; if (!son[k][p]) head = 0; else head = son[k][p]; &#125; ans += w[head]; &#125;&#125;int main()&#123; memset(w, 0, sizeof w); memset(son, 0, sizeof son); memset(fail, 0, sizeof fail); scanf("%d%d", &amp;leng, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); len = strlen(s); Trie_build(); &#125; scanf("%s", s); AC_build(); AC_work(); printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大流（最小割）]]></title>
    <url>%2F2020%2F01%2F01%2F%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%88%E6%9C%80%E5%B0%8F%E5%89%B2%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[KM算法]]></title>
    <url>%2F2020%2F01%2F01%2FKM%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[最小费用最大流]]></title>
    <url>%2F2020%2F01%2F01%2F%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[最大流加最短路，每次都找代价最小的增广路。 为什么每次跑最大流之前都要跑一遍最短路呢？因为原来找到的最小代价或次小代价不一定还存在。 洛谷P3381 【模板】最小费用最大流略 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 5005#define M 100005using namespace std;int n, m, s, t, tot = -1, max_flow = 0, min_cost = 0;int st[N], dis[N], cur[N], vis[N], pre[N], min_flow[N], q[N * 200];struct node&#123; int to, last, val, f/*flow*/;&#125;w[M];void add(int u, int v, int f, int ww)&#123; w[++tot].to = v; w[tot].last = st[u]; w[tot].f = f; w[tot].val = ww; st[u] = tot;&#125;bool spfa()&#123; int l = 0, r = 1; q[r] = s; memset(dis, 0x3f, sizeof dis); memset(min_flow, 0x3f, sizeof min_flow); memset(cur, -1, sizeof cur); memset(pre, -1, sizeof pre); dis[s] = 0; vis[s] = 1; while (l != r) &#123; int u = q[++l]; for (int i = st[u]; i != -1; i = w[i].last) &#123; if (w[i].f &gt; 0 &amp;&amp; dis[w[i].to] &gt; dis[u] + w[i].val) &#123; dis[w[i].to] = dis[u] + w[i].val; pre[w[i].to] = u; cur[w[i].to] = i; min_flow[w[i].to] = min(min_flow[u], w[i].f); if (!vis[w[i].to]) &#123; vis[w[i].to] = 1; q[++r] = w[i].to; &#125; &#125; &#125; vis[u] = 0; &#125; return cur[t] != -1;&#125;void dinic()&#123; while (spfa()) &#123; int flow = min_flow[t]; max_flow += flow; min_cost += flow * dis[t]; for (int i = t; i != s; i = pre[i]) w[cur[i]].f -= flow, w[cur[i] ^ 1].f += flow; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); memset(st, -1, sizeof st); for (int i = 1; i &lt;= m; i++) &#123; int u, v, ww, f; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;f, &amp;ww); add(u, v, f, ww); add(v, u, 0, -ww); &#125; dinic(); printf("%d %d\n", max_flow, min_cost); return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匈牙利算法]]></title>
    <url>%2F2020%2F01%2F01%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分图上的大暴力，因为贡献都为一，所以前面的能换就换，不能换就放弃当前节点。思路见030 洛谷P3386 【模板】二分图匹配题目背景二分图 题目描述给定一个二分图，结点个数分别为n,m，边数为e，求二分图最大匹配数 输入输出格式输入格式： 第一行，n,m,e 第二至e+1行，每行两个正整数u,v，表示u,v有一条连边 输出格式： 共一行，二分图最大匹配 输入输出样例输入样例#1： 12 1 1 1 1 1 输出样例#1： 1 1 说明n, m小于等于 1000，u和v分别为小于n、m的正整数。 因为数据有坑，可能会遇到 v&gt;m 的情况。请把 v&gt;m 的数据自觉过滤掉。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m, p, tot = 0, ans = 0;int a[1001], b[1001], t[1001][1001], vis[1001];int dfs(int u)&#123; for (int v = 1; v &lt;= m; v++) if (t[u][v] &amp;&amp; !vis[v]) &#123; vis[v] = 1; if (!b[v] || dfs(b[v])) &#123; a[u] = v; b[v] = u; return 1; &#125; &#125; return 0;&#125;void maxmatch()&#123; for (int i = 1; i &lt;= n; i++) if (!a[i]) &#123; memset(vis, 0, sizeof vis); ans += dfs(i); &#125; printf("%d\n", ans);&#125;int main()&#123; memset(a, 0, sizeof a); memset(b, 0, sizeof b); memset(t, 0, sizeof t); scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= p; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); if (x &gt; n || y &gt; m) continue; tot++; t[x][y] = 1; &#125; maxmatch(); return 0;&#125;]]></content>
      <categories>
        <category>二分图</category>
      </categories>
      <tags>
        <tag>最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tarjan全家桶]]></title>
    <url>%2F2020%2F01%2F01%2FTarjan%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[建立在dfs序和时间戳上的各种操作，重点理解两者的定义和之间的关系。 有向图强连通分量思路见030 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 10010;const int M = 10010;int n, m, top, num, tot = 0, sum = 0, st[N], last[M], to[M], dfn[N], low[N], vis[N], z[N];void tarjan(int u)&#123; dfn[u] = low[u] = ++tot; z[++top] = u; vis[u] = 1; for (int i = st[u]; i ; i = last[i]) &#123; if (!dfn[to[i]]) &#123; tarjan(to[i]); low[u] = min(low[u], low[to[i]]); &#125; else if (vis[to[i]]) low[u] = min(low[u], low[to[i]]); &#125; if (dfn[u] == low[u]) &#123; do &#123; printf("%d ", z[top]); vis[z[top]] = 0; top--; &#125;while (u != z[top + 1]); printf("\n"); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); to[i] = v; last[i] = st[u]; st[u] = i; &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) &#123; memset(z, 0, sizeof z); top = 0; tarjan(i); &#125; return 0;&#125; 割点两个割点之间即为点双，030 例题：JZOJ 3896123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 50010;const int M = 200010;int n, m, tot = 0, cnt = 0, st[N], last[M], to[M], dfn[N], low[N], ans[N], t[N], vis[N];void add(int u, int v)&#123; to[++cnt] = v; last[cnt] = st[u]; st[u] = cnt;&#125;void tarjan(int u, int f)&#123; dfn[u] = low[u] = ++tot; int sum = 0; for (int i = st[u]; i ; i = last[i]) &#123; if (!dfn[to[i]]) &#123; tarjan(to[i], u); low[u] = min(low[u], low[to[i]]); if (low[to[i]] &gt;= dfn[u] &amp;&amp; !vis[u]) &#123; vis[u] = 1; ans[++ans[0]] = u; &#125; &#125; else if (to[i] != f) low[u] = min(low[u], dfn[to[i]]); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); add(u, v); add(v, u); t[i] = 1; &#125; tarjan(1, 0); sort(ans + 1, ans + ans[0] + 1); for (int i = 1; i &lt;= n; i++) printf("%d ", ans[1]); return 0;&#125; 桥两条桥之间即为边双，030 把割点稍加修改即可 缩点把联通分量缩成一个点]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队全家桶]]></title>
    <url>%2F2020%2F01%2F01%2F%E8%8E%AB%E9%98%9F%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[EXKMP]]></title>
    <url>%2F2020%2F01%2F01%2FEXKMP%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[KMP]]></title>
    <url>%2F2020%2F01%2F01%2FKMP%2F</url>
    <content type="text"><![CDATA[核心思想是找到原串每个前缀的 最长的 与后缀相同的前缀，从而实现跳跃。思路见030，精炼易懂。注意重点理解next数组定义，与ｉ,ｊ的初始值。 题目描述如题，给出两个字符串s1和s2，其中s2为s1的子串，求出s2在s1中所有出现的位置。 为了减少骗分的情况，接下来还要输出子串的前缀数组next。如果你不知道这是什么意思也不要问，去百度搜[kmp算法]学习一下就知道了。 输入输出格式输入格式： 第一行为一个字符串，即为s1（仅包含大写字母） 第二行为一个字符串，即为s2（仅包含大写字母） 输出格式： 若干行，每行包含一个整数，表示s2在s1中出现的位置 接下来1行，包括length(s2)个整数，表示前缀数组next[i]的值。 输入输出样例输入样例#1： 输出样例#1： 说明时空限制：1000ms,128M 数据规模： 设s1长度为N，s2长度为M 对于30%的数据：N&lt;=15，M&lt;=5 对于70%的数据：N&lt;=10000，M&lt;=100 对于100%的数据：N&lt;=1000000，M&lt;=1000 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m, next[1000001], i, j;string a, b, c, d;int main()&#123; memset(next, 0, sizeof next); cin &gt;&gt; c &gt;&gt; d; n = c.length(); m = d.length(); for (i = 0; i &lt; n; i++) a[i + 1] = c[i]; for (i = 0; i &lt; m; i++) b[i + 1] = d[i]; for (i = 2, j = 0; i &lt;= m; i++) &#123; while (j &gt; 0 &amp;&amp; b[i] != b[j + 1]) j = next[j]; if (b[i] == b[j + 1]) j++; next[i] = j; &#125; for (i = 1, j = 0; i &lt;= n; i++) &#123; while (j &gt; 0 &amp;&amp; (j == m || a[i] != b[j + 1])) j = next[j]; if (a[i] == b[j + 1]) j++; if (j == m) printf("%d\n", i - j + 1); &#125; for (i = 1; i &lt;= m; i++) printf("%d ", next[i]); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主席树（可持久化线段树）]]></title>
    <url>%2F2020%2F01%2F01%2F%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[主席树用于维护多个版本的线段树。由于开多颗线段树的话空间会炸到飞起，所以可以充分利用每棵线段树中的重复部分。比如在第$i + 1$的版本的末尾新增一个节点，第$i + 1$棵版本的线段树和第i棵线段树的区别只是rt的右儿子及其子树中的一小部分。我们就可以在每一次更新版本时，另开那些有变化的节点，并与没有变化的节点连边（我们把这称之为动态开点），再把新版本的根节点存起来，这样即可节省大量空间。查询仿照普通线段树即可， 注意事项有些题目一开始一定要开一棵空树； JZOJ 3794 高级打字机Description早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。请为这种高级打字机设计一个程序，支持如下3种操作：T x：在文章末尾打下一个小写字母x。(type操作)U x：撤销最后的x次修改操作。（Undo操作）（注意Query操作并不算修改操作）Q x：询问当前文章中第x个字母并输出。（Query操作）文章一开始可以视为空串。 Input第1行：一个整数n，表示操作数量。以下n行，每行一个命令。保证输入的命令合法。 Output每行输出一个字母，表示Query操作的答案。 Sample Input123456787T aT bT cQ 2U 2T cQ 2 Sample Output1bc Data Constraintn&lt;=100000；Undo操作可以撤销Undo操作。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int N = 10000007;int n, tot = 0, cnt = 0, t;int rt[N], lson[N], rson[N], len[N];char v[N], c;void add(int &amp;cur, int po, int l, int r, int last)&#123; if (!cur) cur = ++tot; if (l == r) &#123; v[cur] = c; return; &#125; int mid = (l + r) &gt;&gt; 1; if (po &lt;= mid) rson[cur] = rson[last], add(lson[cur], po, l, mid, lson[last]); if (mid + 1 &lt;= po) lson[cur] = lson[last], add(rson[cur], po, mid + 1, r, rson[last]); &#125;char ask(int po, int cur, int l, int r)&#123; if (l == r) return v[cur]; int mid = (l + r) &gt;&gt; 1; if (po &lt;= mid) return ask(po, lson[cur], l, mid); if (mid + 1 &lt;= po) return ask(po, rson[cur], mid + 1, r);&#125;int main()&#123; scanf("%d", &amp;n); memset(rt, 0, sizeof rt); memset(lson, 0, sizeof lson); memset(rson, 0, sizeof rson); memset(len, 0, sizeof len); for (int i = 1; i &lt;= n; i++) &#123; char type; scanf(" %c", &amp;type); if (type == 'T') &#123; scanf(" %c", &amp;c); len[++cnt] = len[cnt - 1] + 1; add(rt[cnt], len[cnt], 1, N, rt[cnt - 1]);//r在这道题中一定要是常数N哦，不然不变化的节点所代表的区间就不一样了 &#125; if (type == 'U') &#123; scanf("%d", &amp;t); len[++cnt] = len[cnt - t - 1]; rt[cnt] = rt[cnt - t - 1]; &#125; if (type == 'Q') &#123; scanf("%d", &amp;t); printf("%c\n", ask(t, rt[cnt], 1, N)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to 2020]]></title>
    <url>%2F2019%2F12%2F31%2FWelcome-to-2020%2F</url>
    <content type="text"><![CDATA[请输入魔法口令。 546f379165e080a84c4c512bcc227a68de6d6aaba2efa01682f7e7ff08737c19e2cd8bbc256ec01e0732f07cafba85ddc1a58e4777d0803779c6cea7666aa107c4cb68bf96e58d42eda11bc122145d9a0b75d2508177540bbf2e760d19385931190b766f15b87d524ad0070f8e06e6eb54308264ab23981adc65178bd4cb2465b69f211ed87b1ba494d01013e96f7f632bfed000decb2d402deb0b08b502dc1a1b958bb3590a6831a13842b30ea8b5c294701169f4d1dd69a1a3c5f111eb727edcf9abc667126d9c2f20b15b7674427226afa894334e0bc2927f30021ff95c1100bd9242ae95ce5272a8dbcb5f21a07ff5bc8b02097a642fd59565966c6a8ceb2cc721b99fb5cfd1b46371ab84be9592b37ce309966c492023db50f043ed0af5e7b676149a8748f109760620d360577fc9e7b86b8e5a4cd5f8418f6c321ce1928f56add8f12526f542bc1773e35ea77003a5b0b3567247bd9ee3c22e78571fb5d6b4e4628a32a85d55826c93d54d84d315e6932573fc1066a5c1edd5d3fec16c25e1837972cd9f967dd514d2b41b0b81a232303ae3f90aeac3b8988f7d17bfaa942c2b65e4464cc5207dad776b4308ef9ee0d7bb807147a72644e6eab6fbef311aeee3ee81ca870b7cfce812b947d044a2ce0477ee31a1a15e621203771755fdd800f881476ab89378d52d247e97d73542738b76517ccb93d78a03f4e2483016c21bc43052157681b7e48ae6746c95c5401431e4e414095db3b1113579c9a154ac38f97e014bfa6cc8fa435d3f29a57528098719616be1ad92e3a951049dd7070cd0d095607e59b236197fa911f7853382149215d90e0d8f3222c0c36165809cb44710fad18ab537b09925160606f44b2874745686a85f0f94ce1597ad6712a288d75ab46fb9ceeb24a21911a3113be842f6b2c0fc22a07466da676028e05e9af3707cffd1a6df964e09375f382e29b5f793d53dd7fb61b923e61900b024e9664d7b5cda827a9a7bb9e79e7fbb0509252bc0f2fd2d11b0dd6059a8c2c79fa88db1240f0d63fbda40d6eebd038a61978a77c846f1bf7a151cc81a6d249d6ca4d57a4f1383b5aa6de479c8fd6ffdd4798fa933988688401d0d7d87a77d6c943adc3cfadffadfafe362929d48e81372b37f9b49a673ef54d1cd4a2917c7712717eab872aa8d4a8f3051b56c9eaf0cb2016bb5477af27cb469d2bffa81879f85692eff7197b9c3651fd7f1f0f599c0027357a5e6a49762735dc8553224375d30056a78776a5947fa76c42586ff6e7e09d0764600bd5740436198d26eba89981336bbe724ba811b46eb8a304e29c4cef2cb9c131d6be2aa87910801815d166185b2f5fd8c042fce1ca5adb22924bb83b3ed5849fc3b8e844e9c1243e517c8d81955f96c6839390a058a4e1ffee9fb0171b218d0baf5f227a22d2b6951379aac54658ac29653137d9ef496e1feebf7ec7e9f637474d0fa7b47aa22bee8fe27f4b17998e4938087ad696d096cdc0a98867b0cff916468c6abd1275e663ff689ec8d4a588d67cae1d3d7b61e7f801f6550a3c94b83b3788c142feccc397de295d8a2ef7a6959e46093e07aa5abf8c85db5df387e927fe26038e5579fcae978182b6da98c189a03db908b6ab1481ecefcf9c4cf3ac452b59faba65bea966856c79c72cc10f74cdf8474cfe759a0c3bededa50f4352ea99110132f3e1fe529bb515144dc416a0938fa1224c2646d981c2d51acbe41cde6eca81a627349b9238ba4c99e0e207349c95e6136cb0a7c39b272babef5622f7d8ce4581e664c57035011c0a818b0346ce39c0c58d934c264e416beed63f1e97d8b4d0dcdfc43144a202a3ecee2af3cf99770a03e00d7c486dbeabb70b91b89b3831ec78caa12db5f54a11f6c85f3211eb3b390167b4400ea44bedf4b830ebf873eb0bd6a6c602e808b3885dac5965e699c343e785755e6cc97510bc981eae94aaffc33b1202fe4a221ab9885f2f40df19ce7dff6246c058be59276189aa0d552d8eda5e04956c06793e09ae2748ef46b3ff163a2a0f055ddbed8e5fc1bcda889e4a4f91ef3bb2304052bb076bfc78a92ce01d4d5abf3fad9e844f9e598a7f23dafeba39114dee0bab1fa93ab822c1d54549b15e92dcfbea92bc9190cf65daf1718a9c4a994e53486b3447ff5dc6ab740127c34474e04d3327f321a6a0c9f24be1d528651f55b1c0cedac1e2db8bd2f40ff22ebbb1df6082d1886264952e7c85281ae4479a2d6a6a750d6a952584bfeabad47158f92edaf6de540eb5ff6265f028bb044d0272df3c9860708cf6fc738f5f46b80e5f206e19ed68bc7125fd329b8483bffd370376557cf01171efd6df70c36dca9e2227f8b4cb58f70f367dd292ed03073098b1e6c4d0a91b7c7272daa5bcd29a1d3aab54ac732547f1f306ace910ae27932d233a65f5bc864aefd371715c7b6be479441da86a393f18c9325d82e0369dfc3b07c980cd483e1b49baf07c33872b390540368c395c90a4dbf1cc8890037254a04aadcdc10759ebeeb157d425b97dc1740026044b9f3e399f7c88a427c02a9e5545ec9dfb036f4528bbb2532927ec5356d2045a37342b47ffdd505b8b307f149a23a24dd0447dc1c7a7e16d92598d7aa7815e5bbd24ff55328a0bcf10cc1fc7fc169598668d19224d9113cf03598c962b806ee752a73f0dc6e3b9ee4cf68ee3fdba2fcfbd0358e7352ea1ab5b3c7e22fa5a55f96dd1293f337edc0441645b07e2f85ecab161cf887d54266fd14ae48f4fbe078824bde7fdaaef532236ce1245cfde178df6144b5c32fb17a608a01bf27d7a6171daa1517176f3b521b232a501282f40b698a71dafa8ba15b6c785254c562f337ae2563f70adba7efa0cb99e21d9184834af84c9aff1c33dc7090b783b32706eb76d730e687901c203acf7e19e644adbf452d995189d72d576c877cc04106da42dd258c69a3788e9b42e38fbd268ca71da079b1206e9e5e022064f039c0a5020688c4e62dca9c15321e6622eb3d649ad371b836fef95da6a31e067da445f657d991afbb5ea7d3bc832bea0e6cf22fb0bcba57436603156a3f1c2f497fc9111ae4f364daa14c271eb1e5c30d5c0f0c42ebe50bc38cd514f0977e5643da1c17dbb620bbdaee0e3c9cccc6869ab907c6e8dd8b856e93c593fdffb506140b718a588a9baf2076202587bc96d5768fc73835e36f19976b82233d62da6be6fd167839d5706d9c0c0f640d2bf2ddc1ca2cecc1dce4f022beadbd3893f6d9903860566fb98213caa9777f731025c544119b3411c96daba13d2a4465c50df466d81ff6a533e365d6b0f72287d71fc81cb30556606a1b401be6fe1cef309c6bb7a9cefc4caed8f5a89a038e20a9ae966dcb658e9df509bc38a150108863daef5c9ed9386265383fec6dd2624b43edd68e6ad8538455d0856c8fdb999f4ab05319c8b3f92b14c3e4b05c9acff0213e0e959a61cc01ffd70a66eefa8c23e9b01fffbe95008d268a0531c31e8d7ffe55a65d94c7331b25af62f0aab1e5233f6f142b1ce2c2b7daaef8551b926ef027b2c8da23de195c3e759f7978dcdecf2758913a606350be07b207ec2341bd20ad48bd633d9965462a2102db94c77f7083e33d4e464f229c4bd0cddee32afac63746954b464ed1c946cca90a0b469ffa76132a83f43a6fcf434bb31d24d2abf0ff632a3602f17b41d5aeb67bf7de08284f2f2fd88f88f67e6280b9a578640599e979d46c347cf8887b642ff09ea7a882297e409b432bfd085fdfd6c2788c47d2c29019d0755275d886bb59fce5c953e045cd117d27985d3a30ea4ef19d824d5aa7fae4ae0a87e5906fa52897b56fda1cdd9041c727a3be9e309f3d3a7b3c6ec92be841dc4b2d359ebe376bacdfba78f19c31e75edc413fd02d399b497299b3a7ff7e6974036fecbc216bc36909d5d4a368ee3c19004a4a596adf83a4dcf75e7a70a400ef29e5acaac12077c15502ca080fabd3d20095f7d7694d1c88b1b1977ad8d86897397797f517632ab3219551076b9abe8539195b3237ec12a224074a92b089e01ba7522e8db8b7e5b7b95d7a141a423e5a2f25b6ef696e1f1eea39f64eef5de2566e702ea149d87220c8d3bd4499804098a726ec3c7454974ad8ac8f38e1782bf257a0e74b9a5acbe4aa128b7ad2ce2ed597f6551bde9ffac980d1d02cf041d8ccfa3b407bd56c3c7af3499b1da656dc8c9803fdab5f8865216f6a4a5b9497087358ba390a2a82593ce06049fd84f54889b19cbc9f3a2c7d53ca7c34505f11c58aadf33ac9743b97c24a9626d5ee30c5c535d4f30b7e7d0aab11ee6bd4cf8c8ac19c6b2db98f484c3698f4d31ae0a881fe073bdf571c54b8e33af48bc2b3d9038de4f73821bfeafa39ddcfaa8df74941b7c6d1c113dff0e844059130420b2a325ff102ac65ab9843bdefaf285bee6f758eb812633f428f3d632455f65711e0c41532ca9afbf045b82ac68be7d65c7515e013140ffa5f352632237f72e26fdc2e497c0810654ef3ef191d55ba16fb0c9469b56e4d00f285f72d83f1da44cf75a702380cfe7eb34754aa361e6eda3cf6776b1c20b61652c85a042415d8cddde52fd3ab0c2e0028f40788af09aef26b17fd715455eed3013a687c1f0e4c1f9bd5b6aac7969ca4d35d00ea4b40f7a9ef7875fecbb14f7b559bd051fabc4e6f84383b1ace2c9fdc987e32e8750c585bc211f0699317d4cdc7af5c5082af2521d89ef8b098af84a5addf3a196fb4c4d53157a5d1de0f3e79dca08f9ab7052e4c07c5a6e330dd0bfdc9ead6d3b298ed46fad1a276f27c7b3dc9746c77ff48283b7001b58e04b2a6993406df6581ae40bb774a6b7a407a843b2146539b6cdd4eb55e049d664f59fff0d62f0ff8fb6e8501513a34d367514880c0dc0506557e2934239b27ecc7a47376b71bd9bb3da2b91729334ee4e6420935ae3d94062a22057fdf49b9fe0b6e30c7e0a03808a796866f709b8694f00535056620f8f31784c698f3926aba49d222c4e7498d5cea7bbaa44e6505ee077705244f68d50f89109f4452a5d0baca2841f2ad8cd9b9aedf164043f30ea8b12605f001dfd6c5c0ca952f020689a5ba07193c5959caf7916b5f3ddc2d00959d159a6ab6ef1fd610898b9fdbc18024d4798054438bebaddfed047578216ce13b4d9f4f0c59dfdf5ceff60453500a929bf308112febb17f32a6b79b493aea913442183cc70f9d18a1ab519121c304a77dc538507f0b2daf140d15555da3daa7b3984f60e6db7a0f2470677820d67d62f2889f26f2a7bcc357ffa5f085deb6808d9430d8aecb1bbfffdebcf4f5a42ddfa67de60db3d424a51360e7b9630b45dd54d646e6dfe29957dec64c0808309deb7d1ce838b36d7a10ae4cf0713a319436eb4a5fe807e7b590acb9d22f7ee9cd68f7b736fcff62124bc1184b8cc85c5a07355657853d9397078a60c1dc4fc7b7b62bd809eeed8705dede1a72ebb4a0c61c2f19653e69ec17d0bae2d63916c7752093f04fd19ffeae160e61710f845135d75cdc75c7a954d7af72c1fab9066aa16d6c9b98f88ed0e759b122b6e6e25e6c3fe2135f838f252cda5a10fd3c15b69adf484de96b3d6aed657e7503b01b23e9be875cf271af2a4d389b445d3a5c681b370da99c427538744b9b4db90a8129c061c7ab0792c30662feb82fe28b6f90b57e61c504317d300f2a9e7b1729f8b048eea85153309d0979770d5a8cd73ec06bfa5a84fd48bb08350aad3b4e2942277cce8e6f703af0beba2de6ec569ab8a6d8197090c0f51d1d7571b9747e575d562d6c17d71eb19bd29064b6f4f08429d0a85a41b4fcd69960a164e879c1bd9c5e8aceb3e7d3893c132cc82c6d90528a514f92b2a818d51ee4f61d71a5fac56d647ce03b7f4c88163ec723d66cd4bfb18955c6738dfb6ff2592370c056a18960fe338803fecaf08bf865d075840882e0a5bf74f60dd3d15f187d43eb5453fe6340344892dfee025ae08c574ab76b36a3344a0fafaaa33c8ca724361bba5077]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my garden.]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JZOJ4787. 数格子]]></title>
    <url>%2F2019%2F06%2F01%2FJZOJ4787-%E6%95%B0%E6%A0%BC%E5%AD%90%2F</url>
    <content type="text"><![CDATA[Description你有多少种方法用$2 \times 1$的多米诺骨牌填满$4 \times N$的矩形。答案会很大，所以你只需输出答案模$M$的值。 Input读入包括多组测试数据，以两个0结尾，每个测试点测试组数不超过10组。每组数据包含两个整数，$N$，$M$。 Output每行输出答案模$M$的值。 Sample Input 1 100003 100005 100000 0 Sample Output 11195 Data Constraint对于30%的数据，$1 \leq N \leq 8$。对于80%的数据，$1 \leq N \leq 10 ^ 5$。对于100%的数据，$1 \leq N \leq 10 ^ 9，1 \leq M \leq 10 ^ 5$。 80%解法$4 \times N$，一看就是状压DP，设$f[i][j]$第i列状态为j的方案数，J的每一位上0表示对下一位无影响，1表示有影响，可知$ans = f[n][0]$。可发现$f[i - 1][j]$和$f[i][k]$满足以下条件才可转移： j &amp; k = 0（j 和 k 不能有某一位同时为1）； j 和 k 都为0的位数必须为偶数并且连续。 可发现无论 i 为何值，j 状态是否能转移到 k 状态都是确定的，所以可以dfs做出转移矩阵，然后暴力转移，可拿到80分部分分。 100%解法做出转移矩阵后可发现我们推出来的DP转移式可用矩阵乘法计算，则可以用矩阵快速幂加速。注意几个可能出错的细节：矩阵乘法只满足乘法结合律，不满足乘法交换律，所以快速幂时注意相乘的顺序。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;iostream&gt;#define N 16using namespace std;int n, m, g[4];struct arr&#123; long long a[N][N];&#125;ans, f, p;void dfs(int l, int k)&#123; if (k &gt;= N) return; int flag = 0; for (int i = 0; i &lt; 4; i++) &#123; if ((1 &lt;&lt; i &amp; k) &amp;&amp; (1 &lt;&lt; i &amp; l)) &#123; f.a[k][l] = 0; dfs(l, k + 1); return; &#125; if (!(1 &lt;&lt; i &amp; k) &amp;&amp; !(1 &lt;&lt; i &amp; l)) flag++; else if (flag &amp; 1) &#123; f.a[k][l] = 0; dfs(l, k + 1); return; &#125; else flag = 0; &#125; if (!(flag &amp; 1)) f.a[k][l] = 1; dfs(l, k + 1); return;&#125;arr ti(arr x, arr y)&#123; arr z; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) &#123; z.a[i][j] = 0; for (int k = 0; k &lt; N; k++) z.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j]) % m; &#125; return z;&#125;arr ksm(arr a, int b)&#123; if (b == 1) return a; arr c = ksm(a, b &gt;&gt; 1); if (b &amp; 1) return ti(ti(c, c), a); else return ti(c, c);&#125;int main()&#123; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; 4; j++) g[j] = 1 &lt;&lt; j &amp; i; dfs(i, 0); ans.a[i / 4][i % 4] = 0; &#125; ans.a[0][0] = 1; while (1) &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); if (n == 0 &amp;&amp; m == 0) return 0; p = ti(ans, ksm(f, n)); printf(&quot;%lld\n&quot;, p.a[0][0]); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>JZOJ</tag>
        <tag>矩阵乘法</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZOJ4788. 序列]]></title>
    <url>%2F2019%2F06%2F01%2FJZOJ4788-%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Description有一个包含 n 个整数的序列$A: A_1, A_2, \ldots, A_n$，还有一个包含 n 个整数的序列$B: B_1, B_2, \ldots, B_n$在一次操作中，可以选择两个下标 i 和 j ($1 \leq i \leq j \leq n$)，然后把所有$A_i$到$A_n$之间的元素（包含），增加1之后模4。现在求将$A$数组转换成$B$，至少要执行多少次操作。 Input输入数据的第一行包含一个整数T表示数据组数。对于每组数据，第一行有一个整数，分别表示 n 。接下来两行，第一行包含 n 个数字$A_1, A_2, \ldots, A_n$，第二行包含 n 个数字$B_1, B_2, \ldots, B_n$ Output对于每组数据，输出一行表示对应的答案。 Sample Input 152 1 3 0 32 2 0 1 0 Sample Output 1 Data Constraint$1 \leq T \leq 10$$0 \leq A_i，B_i \leq 3$对于10%的数据满足，$n \leq 30$对于30%的数据满足，$n \leq 100$对于50%的数据满足，$n \leq 1000$对于60%的数据满足，$n \leq 10000$对于100%的数据满足，$n \leq 100000$ 100%解法转自扩展の灰，略作修改。我们可以先考虑不存在Mod 4 的情况，假设$d_i=max(0，b_i-a_i)$那么显然，对于一个位置 i ，我们需要将其操作$max(0，di)$次考虑从1开始，我们设$f[i]$表示将1到 i 的 d 清零所需要的最小次数。显然，$f[1]=d[1]$，$f[i]=f[i-1]+max(0，d[i]-d[i-1])$，这是一个差分的经典应用。现在我们来考虑Mod 4的情况，由于有Mod 4 的影响，我们可以将一系列的$d[i]$变为$d[i]+4k$。这样在一种情况下会减小答案。若有$i&lt;j$使得$d[i]-d[i-1]+4&lt;d[j]-d[j-1]$，那么，我们就可以将整个$[i,j-1]$的d都加上4这样答案就可以减少$(d[i]-d[i-1]+4-d[j]+d[j-1])$实际上，我们只需要维护$d[i]-d[i-1]$ = -2和-3的个数即可。（-1+4=3，0+4=4显然都不可能）每次都贪心地去取就可以。记得如果贪心到$d[i]-d[i-1]=-3$而且$d[j]-d[j-1]=2$时要把$d[i]-d[i-1] = -2$的个数加一，因为后面如果有k满足$d[k]-d[k-1]$=2或3的话把 j 用 k 替换掉是可以更优的。 Code123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int t, n, a[100010], num[4], ans = 0, b;int main()&#123; scanf(&quot;%d&quot;, &amp;t); while (t) &#123; ans = 0; memset(num, 0, sizeof num); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b), a[i] = (b - a[i] + 4) % 4; for (int i = n; i &gt;= 1; i--) a[i] -= a[i - 1]; for (int i = 1; i &lt;= n; i++) &#123; ans += max(a[i], 0); if (a[i] &lt; 0) num[a[i] + 4]++; if (num[1] &amp;&amp; a[i] &gt; 1) num[1]--, num[a[i]]++, ans -= a[i] - 1; else if (num[2] &amp;&amp; a[i] &gt; 2) num[2]--, ans -= a[i] - 2; &#125; printf(&quot;%d\n&quot;, ans); t--; &#125; return 0;&#125;]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>JZOJ</tag>
        <tag>差分</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[球盒问题]]></title>
    <url>%2F2019%2F05%2F31%2F%E7%90%83%E7%9B%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[P.S. 转载至百度文库 一、球相同，盒子相同，且盒子不能空 例1．8个相同的球放入3个相同的盒子中，每个盒子中至少有一个，有多少种不同的放法？ 球入盒问题，可以看成分两步完成，首先是将8个球分成三堆，每堆至少一个. 由于这里球和盒子都相同，每三堆放入3个盒子中只有一种情况，所以只要将8个球分成三堆. 即1-1-6、1-2-5、1-3-4、2-2-4、2-3-3五种，故将8个相同的球放入3个相同的盒子中，每个盒子至少有一个， 有五种不同的放法.结论：ｎ个相同的球放入ｍ个相同的盒子（n≥m），不能有空盒时的放法种数等于ｎ分解为ｍ个数的和的种数. 二、球相同，盒子相同，且盒子可以空 例2．8个相同的球放入3个相同的盒子中，有多少种不同的放法？ 与上题不同的是分成的三堆中，上题中的每一堆至少有一个球，而这个题中的三堆可以有球数为零的堆，即除了分成上面的五堆外，还可分为1-7、2-6、3-5、4-4和只一堆共五种情况，故8个相同的球放入3个相同的盒子中.，有十种不同的放法.结论：ｎ个相同的球放入ｍ个相同的盒子(n $\geq$ m），可以有空盒时的放法种数等于将ｎ分解为ｍ个、(ｍ－1)个、(ｍ－2)个、$\cdots$、2个、1个数的和的所有种数之和. 三、球相同，盒子不同，且盒子不能空 例3．8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个，有多少种不同的放法？（隔板法） 这是个相同的球放入不同的盒子中，与前面不同的是，这里盒子不同，所以不能再用前面的解法. 将8个球排成一排，形成7个空隙，在7个空隙中任取两个插入两块隔板，有=种，这样将8个球分成三堆，第一堆放到1号盒子内，第二堆放到2号盒子内，第三堆放到3号盒子内. 故将8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个，有21种不同的放法.结论：ｎ个相同的球放入ｍ个不同的盒子中（n $\geq$ m），不能有空盒的放法数. 四、球相同，盒子不同，且盒子可以空 例4．8个相同的球放入标号为1、2、3的三个盒子中，有多少种不同的放法？ 与上一题不同的是，这里可以有盒子没放一个.还是利用隔板原理将8个球分为三堆，只不过有的堆的球数为零，即在8个球之间插入两块隔板。首先将8个球排成一排，就有9个空，任取一个空插入一块隔板，有$C^{1}_{9}$种；然后再将第二块隔板插入前面8个球和第一块隔板形成的10个空中，有$C^{1}_{10}$种，但这两种放法中有重复的，要除以2；最后将第一块隔板左边的球放入1号盒子中，两块隔板之间的球放入2号盒子中，第二块隔板右边的球放入3号盒子中，故一共有$\frac{1}{2}C^{1}_{9}C^{1}_{10} = C^{2}_{10} = \frac{10 \times9}{2} = 45$种.或者，将8个球分成三堆（包括没有0数堆和有0数堆），也就是在8个球的9个空隙中取两个插入隔板或取一个插入两块隔板，即$C^{1}_{9} + C^{2}_{9} = 9 + 36 = 45$种.例3也可利用上面的分法来解，8个相同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个. 先放一个到每个盒子中，只有一种放法. 然后将剩下的5个球排成一排，插入两块隔板，有$\frac{1}{2}C^{1}_{6}C^{1}_{7} = C^{2}_{7} = \frac{7 \times6}{2} = 21$种.结论：ｎ个相同的球放入ｍ个不同的盒子中（n $\geq$ m），可以有空盒的放法数. 五、球不同，盒子相同，且盒子不能空 例5．8个不同的球放入三个相同的盒子中，每个盒子中至少有一个，有多少种不同的放法？ 由于盒子相同，所以只要对8个不同的球分成三堆就行了，因为放入盒子只有一种情况. 而8个球分成三堆，各堆球数依次为1-1-6、1-2-5、1-3-4、2-2-4、2-3-3五种. 对情况1-1-6有$\frac{C^{1}_{8}C^{1}_{7}C^{6}_{6}}{2} $种分法，对情况1-2-5有种$C^{1}_{8}C^{2}_{7}C^{5}_{5}$分法，对情况1-3-4有$C^{1}_{8}C^{3}_{7}C^{4}_{4}$种分法，对情况2-2-4有$\frac{C^{2}_{8}C^{2}_{6}C^{4}_{4}}{2}$种分法，对情况2-3-3有$\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}$（注意，分组有几组个数相同即几组均分就要除以几的阶乘）.故一共有$\frac{C^{1}_{8}C^{1}_{7}C^{6}_{6}}{2}+C^{1}_{8}C^{2}_{7}C^{5}_{5}+C^{1}_{8}C^{3}_{7}C^{4}_{4}+\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}+\frac{C^{2}_{8}C^{3}_{6}C^{3}_{3}}{2}=966$种.结论：ｎ个不同的球放入ｍ个相同的盒子中（n $\geq$ m），不能有空盒的放法种数等于ｎ个不同的球分成ｍ堆的种数. 六、球不同，盒子相同，且盒子可以空 例6．8个不同的球放入三个相同的盒子中，问有多少种不同的放法？ 只比上一题多了两种情况，一是有一堆为0的，即分成两堆，1-7、2-6、3-5、4-4四种情况，有；二是有两堆为0的，即只分成一堆，一种情况. 所以一共有966+127+1=1094种.结论：ｎ个不同的球放入ｍ个相同的盒子中（n $\geq$ m），可以有空盒的放法种数等于将ｎ个不同的球分成ｍ堆、(ｍ－1)堆、(ｍ－2)堆、$\cdots$、2堆、1堆的所有种数之和. 七、球不同，盒子不同，且盒子不能空 例7．8个不同的球放入标号为1、2、3的三个盒子中，每个盒子中至少有一个. 问有多少种不同的放法？ 这个问题就等价于“8本不同的书分给3个同学，每人至少有一本，有多少种分法？”就是在例5先分堆的基础上，再加一步，分到三个不同的盒子中. 即966=5796种.结论：ｎ个不同的球放入ｍ个不同的盒子中，不能有空盒的放法种数等于ｎ个不同的球分成ｍ堆的种数乘以ｍ！. 八、球不同，盒子不同，且盒子可以空 例8．8个不同的球放入标号为1、2、3的三个盒子中，问有多少种不同的放法？ 包括分三堆的5796种，还有分两堆的127，还有只分一堆的3种情况，所以一共有5796+762+3=6561种.结论：ｎ个不同的球放入ｍ个不同的盒子中（n $\geq$ m），可以有空盒的放法种数等于$m ^ n$种.]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018NOIP普及组总结]]></title>
    <url>%2F2018%2F11%2F26%2F2018NOIP%E6%99%AE%E5%8F%8A%E7%BB%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[初赛第二次去一中，来的时候坐在车上闭目养神还是挺有用的，至少比赛的时候没有困。到考场以后先熟悉了一下厕所在哪里等等。回来的时候先估了一下分发现发挥正常然后很满足地听起歌，半路中突然发现自己一道选择题排除ABC选B，仍然挺开心的。但是也有很多不足的地方，最后剩的时间大概只有十五分钟。看程序写结果反复看了很多遍（今年这道大题是真的水）。以及最后一道大题的第二题双向链表一脸懵逼，根据多年水题技巧硬生生模拟出来，最后只错了一个空。总结：心态一定一定要稳住！！！不能慌！！！要是因为最后时间很少无法冷静的话是真的凉。 复赛早上磨蹭磨蹭收拾一下东西，再腐败了一会儿就准备上车了，然而这一次在车上大脑兴奋的我又拿起了手机，接着到广州和大家一起吃午饭。这个！！！我要吐槽了！！！好好的一盆粉丝炖肉变成了粉丝炖汤，米饭 = 稀饭，还有lzc点的西红柿鸡蛋馅的饺子？？？西红柿鸡蛋馅？？？以及一盘15块钱的黄瓜连半根都不到，米饭上的时候才都快吃完了。一点都对不起这顿饭的价格_吃完并不愉快的午餐过后到二中的休息室趴了一小会儿，进机房准备比赛。一看旁边坐的就是纪雅的学妹，熟人相见格外亲切呀。比赛的密码扯到了神奇的改革开放。于是开始了炸车之旅。因为是第一次参加NOIP复赛，先很听话地用5分钟把注意事项完整地看了一遍，填好了选手信息。 T1考输入输出 T2考语文水平 T3 + T4一看T3：哦这道题肯定是动规啊，拿起笔唰唰唰列转移方程。然后手算了第二个样例，觉得好像没什么毛病。然后我就开打了。氮素，行云流水地敲出来以后发现——第一个样例错了！我对自己的思路的正确性深信不疑，仗着前两题节省的大量时间，开始与DP的死磕。磕了一个半小时，觉得还是先看看T4。用半个小时打出了第四题的暴力，果不其然因为思路有点乱打错了一点。我想了想，还是觉得马上就能调好T3了，而且T4说不定暴力还拿不到70几（这是我做的最错误的决定）于是又折回去调T3。然而时间不知不觉到了最后十五分钟，我突然发现T3会重复计算，思路是错的，心态炸裂——差点就自暴自弃不想提交前两题了。最后十分钟，终于冷静下来，T4飞速水分，再直接把T3的代码交上去，检查了一遍文件夹。出考场的时候心情真的十分低落。当时真的觉得自己连普及组也拿不到一等奖了。晚上也只是随便吃了点粉。后面紧接着的一周都挺颓废的，也没有去OJ上估分，觉得自己可能拿到提高组一等奖就要退役了。然后某天中午老师突然告诉我说我的官方成绩是247，保证一等奖。但是我当时好像也不是很激动。哦对了，林卓铖因为有西红柿鸡蛋饺子的BUFF拿了315，T4竟然打暴力就能AC！！！！！！！！！！与一百分失之交臂啊。但实际上正解的中序遍历+马拉车我也不会打。 总结：优点：1.把DP的转移方程列了出来，想清楚了思路才开始打；2.先把其他的题看了一下；3.仔细看了注意事项和时限空限文件名，没有犯低级错误。 需要改进的：1.考场上要先想清楚思路和对题目的理解是否正确，手算一下小样例；2.先把能拿到的暴力分拿到再尝试去打正解，不要得不偿失；3.一定要保持理智，不要自暴自弃;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>NOIP</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
